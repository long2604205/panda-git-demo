<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monaco Merge Conflict Editor (Vanilla JS)</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Monaco Editor Loader -->
    <script>
        var require = { paths: { 'vs': 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs' } };
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.36.1/min/vs/loader.min.js"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #1e1e1e; font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; }

        /* Loading Overlay */
        #loading { position: absolute; inset: 0; display: flex; justify-content: center; align-items: center; color: #6b7280; z-index: 50; background: #1e1e1e; }

        /* Editor Container */
        #editor-container { width: 100%; height: 100%; }

        /* VS Code Style Merge Conflict Colors */
        .merge-conflict-current-header { background-color: rgba(64, 200, 174, 0.5) !important; }
        .merge-conflict-current-content { background-color: rgba(64, 200, 174, 0.2) !important; }
        .merge-conflict-incoming-header { background-color: rgba(0, 122, 204, 0.5) !important; }
        .merge-conflict-incoming-content { background-color: rgba(0, 122, 204, 0.2) !important; }
        .merge-conflict-splitter { background-color: rgba(255, 255, 255, 0.2) !important; }
        .merge-conflict-marker-text { color: #a0a0a0 !important; font-weight: bold; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: #1e1e1e; }
        ::-webkit-scrollbar-thumb { background: #424242; border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: #4f4f4f; }
    </style>
</head>
<body class="flex flex-col h-screen text-white bg-[#1e1e1e]">

<!-- Header -->
<div class="flex items-center justify-between px-4 py-2 bg-[#2d2d2d] border-b border-[#1e1e1e] h-10 shrink-0">
    <div class="flex items-center space-x-2">
        <span class="font-medium text-sm text-gray-300">JAVA MERGE CONFLICTS (VANILLA JS)</span>
    </div>
    <div class="text-sm">
            <span id="conflict-badge" class="px-2 py-0.5 rounded text-xs font-bold bg-green-700 text-white">
                0 CONFLICTS
            </span>
    </div>
</div>

<!-- Main Content -->
<div class="flex-1 relative">
    <div id="loading">Loading Editor...</div>
    <div id="editor-container"></div>
</div>

<script>
    // --- 1. Constants & Data ---
    const INITIAL_CODE = `public class Calculator {

    public static void main(String[] args) {
        System.out.println("Simple Calculator");
    }

<<<<<<< HEAD
    public int add(int a, int b) {
        // Current implementation uses simple addition
        return a + b;
    }
=======
    public int add(int a, int b) {
        // Incoming implementation logs the operation
        System.out.println("Adding " + a + " and " + b);
        return Math.addExact(a, b);
    }
>>>>>>> feature/logging-upgrade

    public int subtract(int a, int b) {
<<<<<<< HEAD
        return a - b;
=======
        // Prevent negative results
        if (b > a) return 0;
        return a - b;
>>>>>>> feature/safe-math
    }
}
`;

    // --- 2. Helper Logic (Pure JS) ---
    function findConflicts(model) {
        const text = model.getValue();
        const lines = text.split('\n');
        const conflicts = [];

        let inConflict = false;
        let currentStart = -1;
        let splitter = -1;

        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            const lineNum = i + 1;

            if (line.trim().startsWith('<<<<<<<')) {
                inConflict = true;
                currentStart = lineNum;
            } else if (inConflict && line.trim().startsWith('=======')) {
                splitter = lineNum;
            } else if (inConflict && line.trim().startsWith('>>>>>>>')) {
                if (currentStart !== -1 && splitter !== -1) {
                    conflicts.push({
                        startLine: currentStart,
                        splitterLine: splitter,
                        endLine: lineNum,
                        startHeader: lines[currentStart - 1],
                        endHeader: line
                    });
                }
                inConflict = false;
                currentStart = -1;
                splitter = -1;
            }
        }
        return conflicts;
    }

    // --- 3. Monaco Initialization ---
    require(['vs/editor/editor.main'], function () {

        // Create Editor
        const editorElement = document.getElementById('editor-container');
        const editor = monaco.editor.create(editorElement, {
            value: INITIAL_CODE,
            language: 'java',
            theme: 'vs-dark',
            fontFamily: 'Fira Code, Consolas, monospace',
            fontSize: 14,
            minimap: { enabled: false },
            scrollBeyondLastLine: false,
            codeLens: true,
            automaticLayout: true,
            renderWhitespace: 'none',
            renderValidationDecorations: 'off',
            hover: { enabled: true, delay: 300 }
        });

        // Initialize Decorations Collection
        let decorationsCollection = editor.createDecorationsCollection([]);

        // UI Elements
        const badgeEl = document.getElementById('conflict-badge');
        const loadingEl = document.getElementById('loading');

        // Hide loading
        loadingEl.style.display = 'none';

        // --- Core Function: Update Decorations & UI ---
        function updateDecorations() {
            const model = editor.getModel();
            const conflicts = findConflicts(model);

            // Update UI Badge
            badgeEl.textContent = `${conflicts.length} CONFLICTS`;
            if (conflicts.length > 0) {
                badgeEl.className = 'px-2 py-0.5 rounded text-xs font-bold bg-blue-700 text-white';
            } else {
                badgeEl.className = 'px-2 py-0.5 rounded text-xs font-bold bg-green-700 text-white';
            }

            // Create Monaco Decorations
            const newDecorations = [];
            conflicts.forEach(conflict => {
                // 1. Current Header
                newDecorations.push({
                    range: new monaco.Range(conflict.startLine, 1, conflict.startLine, 1),
                    options: { isWholeLine: true, className: 'merge-conflict-current-header merge-conflict-marker-text' }
                });
                // 2. Current Content
                if (conflict.splitterLine > conflict.startLine + 1) {
                    newDecorations.push({
                        range: new monaco.Range(conflict.startLine + 1, 1, conflict.splitterLine - 1, 1),
                        options: { isWholeLine: true, className: 'merge-conflict-current-content' }
                    });
                }
                // 3. Splitter
                newDecorations.push({
                    range: new monaco.Range(conflict.splitterLine, 1, conflict.splitterLine, 1),
                    options: { isWholeLine: true, className: 'merge-conflict-splitter merge-conflict-marker-text' }
                });
                // 4. Incoming Content
                if (conflict.endLine > conflict.splitterLine + 1) {
                    newDecorations.push({
                        range: new monaco.Range(conflict.splitterLine + 1, 1, conflict.endLine - 1, 1),
                        options: { isWholeLine: true, className: 'merge-conflict-incoming-content' }
                    });
                }
                // 5. Incoming Header
                newDecorations.push({
                    range: new monaco.Range(conflict.endLine, 1, conflict.endLine, 1),
                    options: { isWholeLine: true, className: 'merge-conflict-incoming-header merge-conflict-marker-text' }
                });
            });

            decorationsCollection.set(newDecorations);
        }

        // --- Core Function: Resolve Conflict ---
        function handleResolve(action, conflict) {
            const model = editor.getModel();
            const lineCount = model.getLineCount();

            const getContent = (startLine, endLine) => {
                if (startLine > endLine) return '';
                const maxCol = model.getLineMaxColumn(endLine);
                return model.getValueInRange(new monaco.Range(startLine, 1, endLine, maxCol));
            };

            const currentContent = conflict.splitterLine > conflict.startLine + 1
                ? getContent(conflict.startLine + 1, conflict.splitterLine - 1) : '';

            const incomingContent = conflict.endLine > conflict.splitterLine + 1
                ? getContent(conflict.splitterLine + 1, conflict.endLine - 1) : '';

            let textToKeep = '';
            if (action === 'current') textToKeep = currentContent;
            else if (action === 'incoming') textToKeep = incomingContent;
            else if (action === 'both') textToKeep = (currentContent ? currentContent + '\n' : '') + incomingContent;

            // Fix newline issue at EOF
            let replaceEndLine = conflict.endLine;
            let replaceEndCol = model.getLineMaxColumn(conflict.endLine);

            if (conflict.endLine < lineCount) {
                replaceEndLine = conflict.endLine + 1;
                replaceEndCol = 1;
            }

            const replaceRange = new monaco.Range(conflict.startLine, 1, replaceEndLine, replaceEndCol);

            editor.executeEdits('conflict-resolver', [{
                range: replaceRange,
                text: textToKeep,
                forceMoveMarkers: true
            }]);
        }

        // --- CodeLens Provider ---
        monaco.languages.registerCodeLensProvider('java', {
            provideCodeLenses: function (model, token) {
                const conflicts = findConflicts(model);
                const lenses = [];

                conflicts.forEach(conflict => {
                    const range = {
                        startLineNumber: conflict.startLine, startColumn: 1,
                        endLineNumber: conflict.startLine, endColumn: 1
                    };

                    lenses.push({
                        range: range,
                        id: "accept-current",
                        command: {
                            id: editor.addCommand(0, () => handleResolve('current', conflict)),
                            title: "Accept Current Change",
                        }
                    });
                    lenses.push({
                        range: range,
                        id: "accept-incoming",
                        command: {
                            id: editor.addCommand(0, () => handleResolve('incoming', conflict)),
                            title: " | Accept Incoming Change",
                        }
                    });
                    lenses.push({
                        range: range,
                        id: "accept-both",
                        command: {
                            id: editor.addCommand(0, () => handleResolve('both', conflict)),
                            title: " | Accept Both Changes",
                        }
                    });
                });
                return { lenses: lenses, dispose: () => {} };
            }
        });

        // --- Listeners ---
        editor.onDidChangeModelContent(() => {
            updateDecorations();
        });

        window.addEventListener('resize', () => {
            editor.layout();
        });

        // Initial Run
        updateDecorations();
    });
</script>
</body>
</html>
